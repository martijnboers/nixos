diff --git a/src/Surface.zig b/src/Surface.zig
index 2df720fcb..57d067baa 100644
--- a/src/Surface.zig
+++ b/src/Surface.zig
@@ -5112,14 +5112,13 @@ fn writeScreenFile(
             .history => history: {
                 // We do not support this for alternate screens
                 // because they don't have scrollback anyways.
-                if (self.io.terminal.active_screen == .alternate) {
+                if (self.io.terminal.active_screen == .alternate)
                     break :history null;
-                }
 
+                const bottom_right = pages.getBottomRight(.history);
                 break :history terminal.Selection.init(
                     pages.getTopLeft(.history),
-                    pages.getBottomRight(.history) orelse
-                        break :history null,
+                    bottom_right orelse break :history null,
                     false,
                 );
             },
@@ -5137,7 +5136,6 @@ fn writeScreenFile(
         };
 
         const sel = sel_ orelse {
-            // If we have no selection we have no data so we do nothing.
             tmp_dir.deinit();
             return;
         };
@@ -5167,7 +5165,43 @@ fn writeScreenFile(
             defer self.alloc.free(pathZ);
             try self.rt_surface.setClipboardString(pathZ, .standard, false);
         },
-        .open => try self.openUrl(.{ .kind = .text, .url = path }),
+        .open => {
+            // Check if $EDITOR is a terminal editor
+            const editor_result = internal_os.getenv(self.alloc, "EDITOR") catch null;
+            defer if (editor_result) |v| v.deinit(self.alloc);
+
+            const editor: ?[]const u8 = if (editor_result) |v|
+                if (v.value.len > 0) v.value else null
+            else
+                null;
+
+            const is_terminal_editor = if (editor) |ed|
+                std.mem.indexOf(u8, ed, "vim") != null or
+                std.mem.indexOf(u8, ed, "nvim") != null or
+                std.mem.indexOf(u8, ed, "nano") != null or
+                std.mem.indexOf(u8, ed, "emacs") != null or
+                std.mem.indexOf(u8, ed, "micro") != null or
+                std.mem.indexOf(u8, ed, "helix") != null or
+                std.mem.indexOf(u8, ed, "hx") != null
+            else
+                false;
+
+            // Terminal editors need a TTY - open in new window via IPC
+            if (is_terminal_editor and editor != null) {
+                var child = std.process.Child.init(&.{ "ghostty", "+new-window", "-e", editor.?, path }, self.alloc);
+                child.stdin_behavior = .Ignore;
+                child.stdout_behavior = .Ignore;
+                child.stderr_behavior = .Ignore;
+
+                _ = child.spawn() catch |err| {
+                    log.warn("failed to spawn new window: {}, falling back", .{err});
+                    try self.openUrl(.{ .kind = .text, .url = path });
+                    return;
+                };
+            } else {
+                try self.openUrl(.{ .kind = .text, .url = path });
+            }
+        },
         .paste => self.io.queueMessage(try termio.Message.writeReq(
             self.alloc,
             path,
